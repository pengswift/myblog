title: 并发编程 - 基础摘要
date: 2015-07-04 17:23:27
tags: 并发编程
---

###并发不完全等于并行
	1. 当多个程序程序同时执行时，并且分别被不同的处理器进行处理时，这才是真正意义上的并行，好比，两辆车分别行驶在不同的马路上。
	2. 当并发的程序分别被执行在不同的通道上，即是并行(多核有可能）， 单核只能是并发
	3. 当只有一个处理器时，同时执行多个程序时，在任何一个时刻点上都只有一个程序在处理运行，但由于程序任务处于不停的切换调度当中，使得程序看起来时并行处理。我们称之为并发
	
	
###IPC(进程间通讯)方式
	1.基于通讯的IPC方式	
		1.1 数据传递 管道(Pipe)和消息队列(Message Queue)
		1.2 共享内存 (Shared Memory)
		
	2.基于信号的IPC方式
		2.1 唯一异步方式
	
	3.基于同步的IPC方式
		3.1 信号灯(Semaphore)
		
###进程的状态
	1.可运行状态(TASK_RUNNING, R)
		表示当时进程将要运行或正在CPU上运行, (注意: 该进程的运行时机是不确定的，取决于进程调度器， 因为单条线路上， 任何时刻时间点内， 可能当前进程时运行状态，但调度的是另一个运行状态的进程)
		
	
	2.可中断的睡眠状态(TASK_INTERRUPTIBLE, S)
		当前进程正在等待某个事件时会进入此状态，同时，该睡眠进程会被放入事件等待队列中， 当有事件发生时， 与之相关联的进程会被唤醒。 
		比如，当前进程睡眠时，会讲当前进程的pid存放入到等待队列中，同时会与可以唤醒它的事件绑定在一起， 当事件发生时，通过便利事件等待队列，会获取需要激活的pid，激活即可。
	
	
	3.不可中断的睡眠状态(TASK_UNINTERRUPTIBLE, D)
		与可中断的睡眠状态类似， 唯一区别的时，当该进程处于此状态时，此进程不会对任何信号作出响应，除非它自己完成自身绑定的事件，主动更改其状态。
		比如，当前进程睡眠是为了等待IO事件的完成， 当IO事件完成后，会主动更改起状态。 在这里， 如果IO没有完成， 我们主动向改进程发送任何信号时， 它自身状态不会改变，但，可中断的可以时时改变，并不完全依赖事件回调。
		
	
	
	4.暂停状态或跟踪状态(TASK_STOPPED或TASK_TRACED, T)
	向进程发送 SIGSTOP信号就会使改进程进入暂停状态， （处于不可中断的睡眠状态不接受此改变）
	
	向进程发送 SIGCONT信号就会使改进程转向可运行状态， 	
	
	5.僵尸状态(TASK_DEAD-EXIT_ZOMBIE, Z)
	处于此状态的进程即将要结束， 但部分信息被保留，等待父进程来为它《收拾》， 默认情况
	
	
	6.退出状态(TASK_DEAD-EXIT_DEAD, X)
	不保留任何信息， 非默认情况， 2种可能
		1.进程消亡时，显示的向父进程发送SIGCHLD信号， 我自己处理自己了，不劳烦父亲大人了
		2.进程分离， 子进程和父进程分别独立运行。我独立了，不用管我了。
		
### 虚拟地址
	
	虚拟地址由 用户空间和内核空间组成， 虚拟内存的最大容量与物理内存大小无关， 系统会虚拟化一块硬盘上的内存用作虚拟内存。所以说，如果用ssd，可大大提高速写速度
	
	
	
### 线程 （TID）
	
	一个线程是某个进程中的一个控制流， 一个进程至少包含一个线程，一个进程的第一个线程会随着它的启动而闯将，这个线程被称之为主线程。
	
	创建线程: pthread_create
	
	终止线程: pthread_cancel
	
	连接终止的线程: pthread_join   连接子线程，当子线程运行结束之后，返回，执行清理操作， 否则阻塞，  如果不被连接，该线程一直处于僵尸状态，不会被系统回收，连接后，变成终止状态。可回收
	
	分离线程: phtread_detach  子线程独立处理，结束时自己清理, 非阻塞
	
	终止线程: pthread_exit  结束自己， 

	


###分时调度模型:
指: 让所有线程轮流获的cpu的使用权，并且平均分配每个线程占用cpu的时间片

###抢占式调度模型:
指: 优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，就随机选择一个线程，使其占用CPU。处于运行的线程会一直运行，直到它不得不放弃CPU


